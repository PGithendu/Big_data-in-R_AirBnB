xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
---
```{r}
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
install.packages("shiny")
library(shiny)
shinyApp(ui = ui, server = server)
install.packages("shiny")
library(shiny)
shiny::runApp("C:/Users/patri/OneDrive/Documents/R/New folder/app.Rmd")
install.packages("shiny")
install.packages("shiny")
library(shiny)
shiny::runApp("C:/Users/patri/OneDrive/Documents/R/New folder/app.Rmd")
shiny::runApp("C:/Users/patri/OneDrive/Documents/R/New folder/app.Rmd")
install.packages("shiny")
library(shiny)
shiny::runApp("C:/Users/patri/OneDrive/Documents/R/New folder")
install.packages("shiny")
install.packages("shiny")
install.packages("shiny")
library(shiny)
shiny::runApp("C:/Users/patri/OneDrive/Documents/R/New folder")
install.packages("shiny")
library(shiny)
shiny::runApp("C:/Users/patri/OneDrive/Documents/R/New folder")
install.packages("shiny")
library(shiny)
shiny::runApp("C:/Users/patri/OneDrive/Documents/R/New folder/app.R")
install.packages("shiny")
install.packages("shiny")
library(shiny)
shiny::runApp("C:/Users/patri/OneDrive/Documents/R/New folder/app.R")
shinyApp(ui = ui, server = server)
shinyApp(ui = ui, server = server)
shinyApp(ui = ui, server = server)
runApp('R/New folder')
runApp('R/New folder')
library(shiny)
---
title: "My Shiny App"
---
#title: "My Shiny App"
runtime: shiny
---
title: "My Shiny App"
library(shiny)
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Hello Shiny!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
# Run the application
shinyApp(ui = ui, server = server)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
# Run the application
shinyApp(ui = ui, server = server)
# Run the application
shinyApp(ui = ui, server = server)
# Run the application
shinyApp(ui = ui, server = server)
# Run the application
shinyApp(ui = ui, server = server)
# Run the application
shinyApp(ui = ui, server = server)
# Run the application
shinyApp(ui = ui, server = server)
# Run the application
shinyApp(ui = ui, server = server)
install.packages("chatgpt")
View(mylist)
sys.setenv(OPEN_AI_KEY = "<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>")
install.packages("devtools")
install.packages("install_github("MichelNivard/GPTdtudio")")
install_github("MichelNivard/GPTdtudio"
)
chatgpt:::run_addin_ask_chatgpt()
chatgpt:::run_addin_ask_chatgpt()
chatgpt:::run_addin_ask_chatgpt()
remove.packages("CHATGPT")
remove.packages("ChatGPT")
install.packages("shiny")
install.packages("shiny")
install.packages("shiny")
install.packages("shiny")
chatgpt:::run_addin_ask_chatgpt()
gptstudio:::addin_chatgpt()
gptstudio:::addin_chatgpt()
remotes::install_version("gptstudio", version = "0.2.0") on R console
remotes::install_version("gptstudio", version = "0.2.0")
gptstudio:::addin_chatgpt()
library(shiny); runApp('R/AirBnB/app (2).R')
runApp('R/AirBnB/app (2).R')
runApp('R/AirBnB/app (2).R')
runApp('R/AirBnB/app (2).R')
runApp('R/AirBnB/app (2).R')
library(shiny); runApp('R/AirBnB/app (2).R')
# Summarize and plot using a consistent method for counting and selecting top 10
apartments_per_host <- df2 %>%
group_by(host_id) %>%  # Assuming host_id uniquely identifies owners
summarise(Num_Apartments = n(), .groups = 'drop') %>%
arrange(desc(Num_Apartments)) %>%
slice_max(order_by = Num_Apartments, n = 10)  # Consistent top 10 selection
# Setting the working directory to where your file is located
setwd("C:/Users/patri/OneDrive/Documents/R")
# Load the .RData file into R session
load("C:/Users/patri/OneDrive/Documents/R/AirBnB.RData")
file.exists("C:/Users/patri/OneDrive/Documents/R/AirBnB.RData")
ls()
# L and R are the AirBnB files after exploring all the rest
head(L)
head(R)
#install.packages("tidyverse")
library(tidyverse)
#install.packages("dplyr")
#install.packages("tidyr")
#install.packages("strignr")
#install.packages("lubridate")
#install.packages("stats")
library(dplyr)
library(stats)
library(tidyr)
library(stringr)
library(lubridate)
#join the 2 dataframes L and R "id" in df L is "listing_id" in df R
df1 <- L %>%
full_join(R, by = c("id" = "listing_id"))
head(df1)
nrow(L)
ncol(L)
nrow(R)
ncol(R)
# the new df has slightly more rows after full join
nrow(df1)
ncol(df1)
# Get the column headers of the data frame L
# Extract the column headers from the data frame L
column_headers <- names(L)
# Print the column headers to the console
print(column_headers)
# Retrieve the column headers again from the data frame L# No text provided
# Nothing to correct
column_headers <- names(L)
# Print the column headers to the console
print(column_headers)
###summary(L)
# See the structure of the dataset
dim(L)
##create a new data frame based on columns of interest for Relationship between prices and apartment features:
#install.packages(c("ggplot2", "corrplot"))
# Load the necessary libraries
library(corrplot)
library(ggplot2)
df2 <- df1[c("id", "host_response_time", "state", "beds", "amenities", "bathrooms", "room_type", "price", "monthly_price", "cleaning_fee", "review_scores_rating", "require_guest_profile_picture", "instant_bookable", "security_deposit", "weekly_price", "square_feet", "accommodates", "latitude", "longitude", "zipcode", "neighbourhood_cleansed", "host_has_profile_pic", "city", "minimum_nights", "maximum_nights" , "host_id" , "host_name" , "reviews_per_month" , "first_review" , "last_review")]
head(df2)
nrow(df2)
# Summary statistics
get_mode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
# List of columns to clean and convert
columns_to_convert <- c("price", "monthly_price", "cleaning_fee", "security_deposit", "weekly_price")
# Loop through each column, clean, and convert to numeric
for (col in columns_to_convert) {
df2[[col]] <- as.numeric(gsub("[\\$,]", "", df2[[col]]))
}
# Ensure that NA values are properly handled and calculate summary statistics
summary_table <- df2 %>%
summarise(
Mean_Price = mean(price, na.rm = TRUE),
Median_Price = median(price, na.rm = TRUE),
Mode_Price = get_mode(price),
Range_Price = max(price, na.rm = TRUE) - min(price, na.rm = TRUE),
Mean_Monthly_Price = mean(monthly_price, na.rm = TRUE),
Median_Monthly_Price = median(monthly_price, na.rm = TRUE),
Mode_Monthly_Price = get_mode(monthly_price),
Range_Monthly_Price = max(monthly_price, na.rm = TRUE) - min(monthly_price, na.rm = TRUE),
Mean_Cleaning_Fee = mean(cleaning_fee, na.rm = TRUE),
Median_Cleaning_Fee = median(cleaning_fee, na.rm = TRUE),
Mode_Cleaning_Fee = get_mode(cleaning_fee),
Range_Cleaning_Fee = max(cleaning_fee, na.rm = TRUE) - min(cleaning_fee, na.rm = TRUE),
Mean_Security_Deposit = mean(security_deposit, na.rm = TRUE),
Median_Security_Deposit = median(security_deposit, na.rm = TRUE),
Mode_Security_Deposit = get_mode(security_deposit),
Range_Security_Deposit = max(security_deposit, na.rm = TRUE) - min(security_deposit, na.rm = TRUE),
Mean_Weekly_Price = mean(weekly_price, na.rm = TRUE),
Median_Weekly_Price = median(weekly_price, na.rm = TRUE),
Mode_Weekly_Price = get_mode(weekly_price),
Range_Weekly_Price = max(weekly_price, na.rm = TRUE) - min(weekly_price, na.rm = TRUE),
Mean_Square_Feet = mean(square_feet, na.rm = TRUE),
Median_Square_Feet = median(square_feet, na.rm = TRUE),
Mode_Square_Feet = get_mode(square_feet),
Range_Square_Feet = max(square_feet, na.rm = TRUE) - min(square_feet, na.rm = TRUE),
Mean_Accommodates = mean(accommodates, na.rm = TRUE),
Median_Accommodates = median(accommodates, na.rm = TRUE),
Mode_Accommodates = get_mode(accommodates),
Range_Accommodates = max(accommodates, na.rm = TRUE) - min(accommodates, na.rm = TRUE)
)
# Display the summary table
print(summary_table)
# Select only the numeric columns relevant for correlation analysis
# Ensure all these columns are correctly formatted as numeric and contain no NA values
numeric_data <- df2 %>%
select(price, beds, bathrooms, monthly_price, cleaning_fee, security_deposit, weekly_price, square_feet, accommodates) %>%
na.omit()  # Removes rows with NA values
# Calculate Pearson Correlation Matrix
pearson_correlation_matrix <- cor(numeric_data, method = "pearson")
print("Pearson Correlation Matrix:")
print(pearson_correlation_matrix)
# Calculate Spearman Correlation Matrix
spearman_correlation_matrix <- cor(numeric_data, method = "spearman")
print("Spearman Correlation Matrix:")
print(spearman_correlation_matrix)
# Selecting the numeric columns for correlation analysis
numeric_df <- df2 %>% select(price, monthly_price, cleaning_fee, security_deposit, weekly_price, square_feet, accommodates, beds, bathrooms)
# Compute the correlation matrix
# Use method = "pearson" for Pearson's correlation or "spearman" for Spearman's correlation
corr_matrix <- cor(numeric_df, use = "complete.obs", method = "pearson")
# Plot the heatmap of the correlation matrix
corrplot(corr_matrix, type = "upper", order = "hclust",
tl.col = "black", tl.srt = 45,
method = "color", addCoef.col = "black",
# Adjust color settings to your preference
col = colorRampPalette(c("#6D9EC1", "white", "#E46726"))(200))
# Create the box plot to show price distribution by room type
ggplot(data = df2, aes(x = room_type, y = price ,fill='lavender')) +
geom_boxplot() +
labs(title = "Price Distribution by Room Type", x = "Room Type", y = "Price") +
theme_minimal()
#creating a box plot comparing review scores across different price ranges. We categorize the price into ranges (low, medium, high).
# First, calculate price thresholds for categories based on quantiles
low_price_threshold <- quantile(df2$price, 0.33, na.rm = TRUE)
high_price_threshold <- quantile(df2$price, 0.66, na.rm = TRUE)
# Categorize price into Low, Medium, High
df2 <- df2 %>%
mutate(price_category = case_when(
price <= low_price_threshold ~ "Low",
price > low_price_threshold & price <= high_price_threshold ~ "Medium",
price > high_price_threshold ~ "High",
TRUE ~ NA_character_  # For missing values
))
# Create the box plot
ggplot(data = df2, aes(x = price_category, y = review_scores_rating, fill='lavender')) +
geom_boxplot() +
labs(title = "Review Scores by Price Range", x = "Price Range", y = "Review Scores Rating") +
theme_minimal()
# Define the dataset and features
features <- c("beds", "bathrooms", "monthly_price", "cleaning_fee", "security_deposit", "weekly_price", "square_feet", "accommodates")
# Inside your loop
for (feature in features) {
plot <- ggplot(df2, aes(x = !!sym(feature), y = price)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = paste("Price vs", feature), x = feature, y = "Price") +
theme_minimal()
print(plot)  # Print the plot to view it
facet_wrap(~trans,nrow=3)
}
# Simple Linear Regression for each feature
for (feature in features) {
formula <- as.formula(paste("price ~", feature))
model <- lm(formula, data = df2)
print(summary(model))  # Output the summary of the regression analysis
# Plotting
plot <- ggplot(df2, aes_string(x = feature, y = "price")) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +
labs(title = paste("Linear Regression of Price on", feature), x = feature, y = "Price")
print(plot)  # Display the plot
}
#Effect of location on price :Renting price per city quarter ("arrondissements"):
# Average, Median Price by Neighbourhood
price_by_neighbourhood <- df2 %>%
group_by(neighbourhood_cleansed) %>%
summarise(
Average_Price = mean(price, na.rm = TRUE),
Median_Price = median(price, na.rm = TRUE),
Price_Range = max(price, na.rm = TRUE) - min(price, na.rm = TRUE)
) %>%
arrange(desc(Average_Price))
# Plot
ggplot(price_by_neighbourhood, aes(x = reorder(neighbourhood_cleansed, -Average_Price), y = Average_Price)) +
geom_bar(stat = "identity") +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = "Average Price by Neighbourhood", x = "Neighbourhood", y = "Average Price ($)")
# Count the number of apartments per host
apartments_per_host <- df2 %>%
group_by(host_id, host_name) %>%  # Group data by host
summarise(Num_Apartments = n_distinct(id), .groups = 'drop') %>%  # Count unique apartments
arrange(desc(Num_Apartments))  # Arrange in descending order of number of apartments
# Print the first 10 results
head(apartments_per_host, 10)
# Summarize and plot using a consistent method for counting and selecting top 10
apartments_per_host <- df2 %>%
group_by(host_id) %>%  # Assuming host_id uniquely identifies owners
summarise(Num_Apartments = n(), .groups = 'drop') %>%
arrange(desc(Num_Apartments)) %>%
slice_max(order_by = Num_Apartments, n = 10)  # Consistent top 10 selection
# Now use apartments_per_host directly for both summary display and plotting
nrow(apartments_per_host)
# Calculate the number of apartments per host
apartments_per_host <- df2 %>%
group_by(host_id) %>%
summarise(num_apartments = n_distinct(id), .groups = 'drop')
# Calculate mean, median
mean_apartments = mean(apartments_per_host$num_apartments)
median_apartments = median(apartments_per_host$num_apartments)
# Calculate mode - R does not have a built-in mode function, so we create one
get_mode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
mode_apartments = get_mode(apartments_per_host$num_apartments)
# Print the results
cat("Mean number of apartments per owner: ", mean_apartments, "\n")
cat("Median number of apartments per owner: ", median_apartments, "\n")
cat("Mode number of apartments per owner: ", mode_apartments, "\n")
# Add year, month, and quarter to your dataset along with a formatted year-quarter label
df2 <- df2 %>%
filter(!is.na(ymd(last_review))) %>%  # Exclude rows where last_review is NA
mutate(
year = year(ymd(last_review)),  # Extract the year from the last review date as a proxy
quarter = quarter(ymd(last_review)),  # Extract the quarter from the last review date
year_quarter = paste(year, "Q", quarter, sep="")  # Create a formatted year-quarter string
) %>%
group_by(year, quarter, year_quarter) %>%
summarise(
average_reviews_per_month = mean(reviews_per_month, na.rm = TRUE),
.groups = 'drop'
)
# Display the summarized table
print(df2)
# Plotting the trend over time with clearer labels
ggplot(df2, aes(x = year_quarter, y = average_reviews_per_month)) +
geom_line(group = 1) +  # Connect points by line; group=1 ensures it's seen as one series
geom_point() +  # Show individual data points
labs(title = "Average Reviews Per Month Over Time",
x = "Year and Quarter",
y = "Average Reviews per Month") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x labels for better readability
# Summarize and plot using a consistent method for counting and selecting top 10
apartments_per_host <- df2 %>%
group_by(host_id) %>%  # Assuming host_id uniquely identifies owners
summarise(Num_Apartments = n(), .groups = 'drop') %>%
arrange(desc(Num_Apartments)) %>%
slice_max(order_by = Num_Apartments, n = 10)  # Consistent top 10 selection
#install.packages("tidyverse")
library(tidyverse)
#install.packages("dplyr")
#install.packages("tidyr")
#install.packages("strignr")
#install.packages("lubridate")
#install.packages("stats")
library(dplyr)
library(stats)
library(tidyr)
library(stringr)
library(lubridate)
# Summarize and plot using a consistent method for counting and selecting top 10
apartments_per_host <- df2 %>%
group_by(host_id) %>%  # Assuming host_id uniquely identifies owners
summarise(Num_Apartments = n(), .groups = 'drop') %>%
arrange(desc(Num_Apartments)) %>%
slice_max(order_by = Num_Apartments, n = 10)  # Consistent top 10 selection
df2 <- df1[c("id", "host_response_time", "state", "beds", "amenities", "bathrooms", "room_type", "price", "monthly_price", "cleaning_fee", "review_scores_rating", "require_guest_profile_picture", "instant_bookable", "security_deposit", "weekly_price", "square_feet", "accommodates", "latitude", "longitude", "zipcode", "neighbourhood_cleansed", "host_has_profile_pic", "city", "minimum_nights", "maximum_nights" , "host_id" , "host_name" , "reviews_per_month" , "first_review" , "last_review")]
head(df2)
# Summarize and plot using a consistent method for counting and selecting top 10
apartments_per_host <- df2 %>%
group_by(host_id) %>%  # Assuming host_id uniquely identifies owners
summarise(Num_Apartments = n(), .groups = 'drop') %>%
arrange(desc(Num_Apartments)) %>%
slice_max(order_by = Num_Apartments, n = 10)  # Consistent top 10 selection
# Now use apartments_per_host directly for both summary display and plotting
# Summarize and plot using a consistent method for counting and selecting top 10
apartments_per_host <- df2 %>%
group_by(host_id) %>%  # Assuming host_id uniquely identifies owners
summarise(Num_Apartments = n(), .groups = 'drop') %>%
arrange(desc(Num_Apartments)) %>%
slice_max(order_by = Num_Apartments, n = 10)  # Consistent top 10 selection
# Now use apartments_per_host directly for both summary display and plotting
# Summarize and plot using a consistent method for counting and selecting top 10
apartments_per_host <- df2 %>%
group_by(host_id) %>%  # Assuming host_id uniquely identifies owners
summarise(Num_Apartments = n(), .groups = 'drop') %>%
arrange(desc(Num_Apartments)) %>%
slice_max(order_by = Num_Apartments, n = 10)  # Consistent top 10 selection
head(apartments_per_host, 10)
# Now use apartments_per_host directly for both summary display and plotting
# Summarize and plot using a consistent method for counting and selecting top 10
apartments_per_host <- df2 %>%
group_by(host_id, host_name) %>%  # Assuming host_id uniquely identifies owners
summarise(Num_Apartments = n(), .groups = 'drop') %>%
arrange(desc(Num_Apartments)) %>%
slice_max(order_by = Num_Apartments, n = 10)  # Consistent top 10 selection
head(apartments_per_host, 10)
# Now use apartments_per_host directly for both summary display and plotting
runApp('R/AirBnB/app (2).R')
shiny::runApp('R/AirBnB_Patrick')
runApp('R/AirBnB_Patrick')
runApp('R/AirBnB_Patrick')
runApp('R/AirBnB_Patrick')
runApp('R/AirBnB_Patrick')
